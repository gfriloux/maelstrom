/*
 * Parts copyright 2006, 2007 Ondrej Jirman <ondrej.jirman@zonio.net>
 * Copyright 2010 Mike Blumenkrantz <mike@zentific.com>
 */

/**
 * Set the namespace to T: this prefixes all generated functions and types with 'T_'
 */
namespace T;

/**
 * define two #Eina_Error codes with values 1, 2
 * set their strings to the value between and including the braces
 * semicolon required, empty error string permitted between braces
 */
error ERR1 = 1 { sup this is an error };
error ERR2 = 2 { chea dawg this is also an error };

/**
 * Create typedef struct named Struct (T_Struct in C)
 */
struct Struct
{
   /** string member named v_string; strings are stringshared
    * const char*
    */
   string v_string;
}

/**
 * Create typedef struct named AllArrays (T_AllArrays in C)
 */
struct AllArrays
{
   array<string>  a_string; /**< array of stringshared strings */
   array<time>    a_time; /**< array of stringshared time strings */
   array<base64>  a_base64; /**< array of stringshared base64-encoded strings */
   array<int>     a_int; /**< array of ints */
   array<boolean> a_boolean; /**< array of Eina_Bools */
  //FIXME array<double>  a_double; /**< array of doubles */
   array<Struct>  a_struct; /**< array of Struct objects (T_Structs in C) */
   array<array<string>> aa_string; /**< array of arrays of stringshared strings */
   array<array<array<string>>> aaa_string; /** array of arrays of arrays of stringshared strings */
}

/**
 * Create typedef struct named AllTypes (T_AllTypes in C)
 */
struct AllTypes
{
   string v_string; /**< stringshared string */
   time      v_time; /**< stringshared time string */
   base64    v_base64; /**< stringshared base64-encoded string */
   int       v_int; /**< int */
   boolean   v_boolean; /**< Eina_Bool */
   double    v_double; /**< double */
   Struct    v_struct; /**< Struct object (T_Struct in C) */
   AllArrays v_arrays; /**< AllArrays object (T_AllArrays in C) */
}

/**
 * Create a module named 'Test1' which can contain methods, structs, errors, etc
 */
Azy_Module Test1
{
   /** <% %> are {} for .azy files and are placed around sections of modules
    * this first section is the includes section which is placed at the top of the
    * generated c code files, so all headers required by the server methods in this
    * module must be included here
    */
   <%
    #include <stdio.h>
    #include <string.h>
   %>

   /**
    * define some module-specific errors which are only used
    * within this module
    */
   error NOTHING = 2 { error messageeeeeeeeeeeeeeee };
   error NO_DATA = 5 { and another errrorrrrrrrrrrrrrrr woooo };

   /**
    * this is a method description for method "getAll" in module Test1
    * with namespace T.  to call this method externally, you would use the string
    * "T_Test1.getAll" in your rpc call.
    * Note, however, that since we are in the .azy file, we can skip using any
    * namespacing IN THE METHOD PROTOTYPE ONLY and just use the types themselves
    * Note also that getAll(void) is not allowed.
    */
   AllTypes getAll()
   <%
   /** begin method code */
     char *buf;
     /** the below line can be uncommented so you can see where it gets called
      * from when the method is called
      */
  //   printf("%s:%s:%d\n", __FILE__, __PRETTY_FUNCTION__, __LINE__);
     retval = T_AllTypes_new(); /**< We are in C here since it is between < % % >
                                     * This means we must use all namespaces. since this
                                     * is a globally accessible struct, it must be prefixed with T_
                                     * Note that using < % % > without spaces in a comment
                                     * will result in a parser error (FIXME).
                                     */
     retval->v_string = eina_stringshare_add("Hi!");
     retval->v_time = eina_stringshare_add("2010-11-01");
     buf = azy_base64_encode("Hi all!", sizeof("Hi all!"));
     retval->v_base64 = eina_stringshare_add(buf);
     free(buf);
     retval->v_int = 5645;
     retval->v_boolean = EINA_FALSE;
     retval->v_double = 123.123e-3;
     retval->v_struct = T_Struct_new();
     retval->v_struct->v_string = eina_stringshare_add("some str");
     retval->v_arrays = T_AllArrays_new(); /**< Again, we're still in C so we must use the T namespace */

     /** The 3 lines below this demonstrate how to use generated copy and eq functions */
     T_AllTypes *orig = retval;
     retval = T_AllTypes_copy(retval); /**< copying is always nullsafe */
     if (!T_AllTypes_eq(retval, orig)) /**< as is eq */
       printf("Error! Copying failed!\n");
     T_AllTypes_free(orig); /**< as is free */
     return retval; /**< as the method prototype describes, this must return a AllTypes (T_Alltypes in C)
                      * struct, so we return one here
                      */
   /** end method code */
   %>

   AllArrays getAllArrays()
   <%
     int i;

     #define ADD(a, val) retval->a = eina_list_append(retval->a, val)

    // printf("%s:%s:%d\n", __FILE__, __PRETTY_FUNCTION__, __LINE__);

     retval = T_AllArrays_new();

     for (i = 0; i < 5; i++)
       ADD(a_string, eina_stringshare_printf("str%d", i));

     ADD(a_string, eina_stringshare_add("&#10;test<\xc4\x8d\xc5\x99\xc5\xa1"));

     for (i = 1; i < 10; i++)
       ADD(a_time, eina_stringshare_printf("2006-04-%02d", i));

     for (i = 0; i < 2; i++)
       {
          const char *buf;
          char *b64;

          buf = eina_stringshare_printf("BBBBBBBBBBBBBBBBBLOOOOOB%d", i);
          b64 = azy_base64_encode(buf, eina_stringshare_strlen(buf));
          eina_stringshare_del(buf);
          ADD(a_base64, eina_stringshare_add(b64));
          free(b64);
       }

     for (i = 0; i < 10; i++)
       ADD(a_int, (void *)&i);

     for (i = 0; i < 10; i++)
       {
          int x = i % 2;
          ADD(a_boolean, (void *)&x);
       }

     //    for (i = 0; i < 5; i++)
     //      ADD(a_double, (void *)(double)(i * 1.11e-3));
     for (i = 0; i < 2; i++)
       {
          T_Struct *s = T_Struct_new();
          s->v_string = eina_stringshare_printf("struct val %d", i);
          ADD(a_struct, s);
       }

     for (i = 0; i < 2; i++)
       {
          Eina_List *a = NULL;
          int j;

          for (j = 0; j < 10; j++)
            a = eina_list_append(a, eina_stringshare_printf("[%d %d]", i, j));

          ADD(aa_string, a);
       }

     for (i = 0; i < 2; i++)
       {
          Eina_List *a = NULL;
          int j;

          for (j = 0; j < 10; j++)
            {
               Eina_List *b = NULL;
               int k;

               for (k = 0; k < 3; k++)
                 b = eina_list_append(b, eina_stringshare_printf("[%d %d %d]", i, j, k));

               a = eina_list_append(a, b);
            }

          ADD(aaa_string, a);
       }

          #undef ADD

     /* test copy/free */
     T_AllArrays *orig = retval;
     retval = T_AllArrays_copy(retval);
     T_AllArrays_free(orig);
   %>

   boolean setAll(AllTypes all)
   <%
     printf("%s:%s:%d\n", __FILE__, __PRETTY_FUNCTION__, __LINE__);
   %>

   array<string> getBigArray()
   <%
     int i;

     for (i = 0; i < 5000; i++)
       retval = eina_list_append(retval, eina_stringshare_printf("user.bob%d@zentific.com", i));
   %>

   boolean putBigArray(array<string> arr)
   <%
     (void)arr;
     return EINA_TRUE;
   %>

   __attrs__
   <%
     const char *username;
   %>

   __init__
   <%
 //    printf("%s:%s:%d\n", __FILE__, __PRETTY_FUNCTION__, __LINE__);
   %>

   __shutdown__
   <%
  //   printf("%s:%s:%d\n", __FILE__, __PRETTY_FUNCTION__, __LINE__);
   %>

   __pre__
   <%
    //printf("Pre-call!\n");
   %>

   __post__
   <%
    //printf("Post-call!\n");
   %>

   __fallback__
   <%
     printf("Unknown method called %s!\n", azy_content_method_get(_content));
     azy_content_retval_set(_content, azy_value_bool_new(EINA_TRUE));
     return EINA_TRUE;
   %>

   /* serve GET request, if serverd return EINA_TRUE, otherwise return EINA_FALSE */
   __download__
   <%
     const char *path = azy_net_uri_get(_net);
     const char *username;
     const char *password;

     if (!azy_net_auth_get(_net, &username, &password))
       {
          azy_net_code_set(_net, 401);
          azy_net_header_set(_net, "Content-Type", "text/plain");
          azy_net_header_set(_net, "WWW-Authenticate", "Basic realm=\"Azy Testsuite\"");
          azy_server_client_send(_net, (unsigned char *)"Authentication Required", 23);
          return EINA_TRUE;
       }

     printf("Authorized: '%s' '%s'\n", username, password);
     eina_stringshare_del(username);
     eina_stringshare_del(password);

     if (1)
       {
          azy_net_code_set(_net, 200);
          azy_net_header_set(_net, "Content-Type", "text/plain");
          azy_server_client_send(_net, (unsigned char *)"Crap\n", 5);
          return EINA_TRUE;
       }
     else
       {
          Eina_Strbuf *response = eina_strbuf_new();
          eina_strbuf_append_printf(response, "<html><head><title>401 Not Authorized</title></head><body><h1>401 Not Authorized</h1><p>You are not authorized to download %s</p></body></html>", path);

          azy_net_code_set(_net, 401);
          azy_net_header_set(_net, "Content-Type", "text/html");
          azy_server_client_send(_net, (unsigned char *)eina_strbuf_string_get(response), eina_strbuf_length_get(response));

          eina_strbuf_free(response);
          return EINA_TRUE;
       }

   %>
/*
        __upload__
        <%
        //	size_t read_bytes;
        //	const char* path = azy_net_resource_get(_net);
                const char* username;
                const char* password;

                if (!azy_net_basic_auth_get(_net, &username, &password))
                {
                        azy_net_code_set(_net, 401);
                        azy_net_header_set(_net, "Content-Type", "text/plain");
                        azy_net_header_set(_net, "WWW-Authenticate", "Basic realm=\"Azy Testsuite\"");
                        azy_server_client_send(_net, (unsigned char*)"Authentication Required", -1);
                        return EINA_TRUE;
                }

                printf("Authorized: '%s' '%s'\n", username, password);
                eina_stringshare_del(username);
                eina_stringshare_del(password);

                Eina_Strbuf* data = azy_net_read_all(_net);
                printf("%s\n", eina_strbuf_string_get(data));
                eina_strbuf_free(data);

                azy_net_code_set(_net, 200);
                azy_net_header_set(_net, "Content-Type", "text/plain");
                azy_server_client_send(_net, (unsigned char*)"Crap\n", -1);
                return EINA_TRUE;
        %>
 */
}

Azy_Module Test2
{
   <%
#include <stdio.h>
#include <string.h>
   %>

   __attrs__
   <%
     const char *username;
     const char *password;
   %>

   __init__
   <%
     Azy_Net *net = azy_server_module_net_get(_module);
     printf("Init AUTH Servlet!\n");
     printf("Accepted connection from: %s\n", azy_net_ip_get(net));
   %>

   __shutdown__
   <%
     printf("Shutdown AUTH Servlet!\n");
   %>

   boolean auth(string name,
                string password)
   <%
     printf("AUTH-PRE:  %s, %s\n", _priv->username, _priv->password);
     _priv->username = name;
     _priv->password = password;
     printf("AUTH-POST: %s, %s\n", _priv->username, _priv->password);
     return EINA_TRUE;
   %>

   string getUsername()
   <%
     return eina_stringshare_add(_priv->username);
   %>
}

Azy_Module SQL
{
   <%
     #include <mysql/mysql.h>
   %>

   __init__
   <%
      mysql_library_init(0, NULL, NULL);
   %>

   __shutdown__
   <%
      mysql_library_end();
   %>

   __attrs__
   <%
      MYSQL *m;
   %>

   boolean test()
   <%
//      static int x;
      T_SQL_Module *data;
      Eina_Bool ret = EINA_TRUE;

      data = T_SQL_module_data_get(_module);
      data->m = mysql_init(NULL);
      if (!mysql_real_connect(data->m, "localhost", "zentific", "zentific", "zentific", 0, NULL, CLIENT_REMEMBER_OPTIONS))
        {
           ret = EINA_FALSE;
           goto out;
        }
      mysql_set_server_option(data->m, MYSQL_OPTION_MULTI_STATEMENTS_ON);

      if (mysql_real_query(data->m, "SELECT 1 = 1", sizeof("SELECT 1 = 1")))
        ret = EINA_FALSE;
out:
      mysql_close(data->m);
//      printf("Call #%i: %s!\n", ++x, ret ? "Success" : "Failure");
      return ret;
   %>
}
